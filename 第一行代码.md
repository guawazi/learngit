# 第一行代码

## MeterDesign


### Toolbar
- 默认的主题

  <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!--actionbar 的颜色-->
        <item name="colorPrimary">@color/colorPrimary</item>
        <!--状态栏的颜色-->
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

- 修改成 NoActionBar

	1. android:theme="@style/Theme.AppCompat.Light.NoActionBar"

		淡色主题，白底黑字
	
	2. android:theme="@style/Theme.AppCompat.NoActionBar"

		深色主题，黑底白字

	3. 布局文件

			<android.support.v7.widget.Toolbar
	        android:id="@+id/toolbar"
	        android:layout_width="match_parent"
	        android:layout_height="?attr/actionBarSize"
	        />

	4. 代码中

			toolbar = (Toolbar) findViewById(R.id.toolbar);
			// 如果主题没有设置成 NoActionBar 则会报错
        	setSupportActionBar(toolbar);

	5. 配置文件中改label 就能改actionbar 的显示内容

	6. 给toolbar 配置OptionsMenu

			1. 先写

			<menu xmlns:android="http://schemas.android.com/apk/res/android"
			    xmlns:app="http://schemas.android.com/apk/res-auto">
			
			    <item
			        android:id="@+id/menu_cart"
			        android:icon="@drawable/cart"
			        android:title="cart"
			        app:showAsAction="always" />
			
			
			    <item
			        android:id="@+id/menu_delete"
			        android:icon="@drawable/delete"
			        android:title="delete"
			        app:showAsAction="ifRoom" />
			
			    <item
			        android:id="@+id/menu_category"
			        android:icon="@drawable/category"
			        android:title="分类"
			        app:showAsAction="never" />
			</menu> 

			2. 重写两个方法
			
				@Override
			    public boolean onCreateOptionsMenu(Menu menu) {
			        getMenuInflater().inflate(R.menu.toolbar, menu);
			        return true;
			    }
			
			    @Override
			    public boolean onOptionsItemSelected(MenuItem item) {
			        switch (item.getItemId()) {
			            case R.id.menu_cart:
			                Toast.makeText(this, "menu_cart", Toast.LENGTH_SHORT).show();
			                break;
			            case R.id.menu_delete:
			                Toast.makeText(this, "menu_delete", Toast.LENGTH_SHORT).show();
			                break;
			            case R.id.menu_category:
			                Toast.makeText(this, "menu_category", Toast.LENGTH_SHORT).show();
			                break;
			        }
			        return true;
			    }

### DrawerLayout

1. 左右都能侧滑
		
		<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    android:orientation="vertical"
		    tools:context="cn.duozhuan.aboutlambda.MainActivity">
		
		    <FrameLayout
		        android:layout_width="match_parent"
		        android:layout_height="match_parent">
		
		        <android.support.v7.widget.Toolbar
		            android:id="@+id/toolbar"
		            android:layout_width="match_parent"
		            android:layout_height="?attr/actionBarSize"
		            android:background="@color/colorPrimary" />
		    </FrameLayout>
		    
		    <TextView
		        android:text="我是左边的侧滑的菜单"
		        android:background="#FFF"
		        android:textSize="36dp"
		        android:layout_gravity="start"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent" />
		
		    <TextView
		        android:text="我是右边的侧滑的菜单"
		        android:background="#FFF"
		        android:textSize="36dp"
		        android:layout_gravity="end"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent" />
		</android.support.v4.widget.DrawerLayout>

		
		要侧滑的都带上了 layout_gravity 属性标识方向

2. 用户不知道有侧滑，加提示

		// 注意这里不是 getActionBar
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null){
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.category);
        }

		 // 这里是 android.R. 不是 R.
            case android.R.id.home:
                drawerLayout.openDrawer(GravityCompat.START);
                break;


### NavigationView

1. 放在侧滑的位置

		   <android.support.design.widget.NavigationView
		        android:id="@+id/navigation_view"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="start"
		        app:headerLayout="@layout/navigation_head"
		        app:menu="@menu/navigation" />

> tips : 上面设置了 layout_gravity 从哪滑出来，headlayout 头布局（高度一般 180）,以及下面的菜单，都很简单

2. 设置监听事件

 		// 设置默认选中的菜单
        navigationView.setCheckedItem(R.id.item_a);
        // 监听完了，注意关闭侧滑  drawerLayout.closeDrawer(GravityCompat.START);
        navigationView.setNavigationItemSelectedListener(this);

### FloatingActionBar

1. 布局

		<android.support.design.widget.FloatingActionButton
		            android:id="@+id/fab"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:layout_gravity="end|bottom"
		            android:layout_margin="15dp"
		            app:elevation="20dp"
		            android:src="@drawable/a" />
> tips : 上面gravity 指定位置，elevation 指定海拔,设置监听事件跟平时一样


### SnackBar

1. 使用

		Snackbar.make(toolbar, "Data delete", Snackbar.LENGTH_LONG)
		                        .setAction("Undo",
		                                v1 -> Toast.makeText(this, "我真的被删除了", Toast.LENGTH_SHORT).show())
		                        .show();

> tips : 第一个传入的view  最好是同一个页面的view，它是用来找最外层布局的，setAction 是特有的，他会给用户提示。有一个问题，就是弹出来会遮住 FloatingBar ，这是因为，snackbar 弹出来后，floatingbar 并没有动，因为它没有接收到这个事件。

### CoordinatorLayout

1. 为了解决，floatingbar 被遮住的问题，要让它对别的控件的行为也作出反应。所以使用  coordinatorLayout,直接将FrameLayout 换成 coordinateLayout 即可。为什么这样就行呢，因为 CoordinateLayout 能监听个子控件的事件，并把它传递下去，SnackBar 好像不属于他的子控件，但是记得 SnackBar 的第一个参数么，只要它是CoordinateLayout 的子控件就行。另外，因为FloatingBar 实现了一个 Behavoir 所以，它能对 SnackBar 的弹出事件作出响应。后面会自己定义Behavoir


### CardView
1. 在上面基础上加上 RecyclerView，然后每个 item 放上 CardView,cardCornerRadius 指定圆角。它是一个FrameLayout 所以，里面放其他布局

		<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    android:layout_width="match_parent"
		    android:layout_height="wrap_content"
		    android:layout_margin="10dp"
		    app:cardCornerRadius="4dp">
		
		    <RelativeLayout
		        android:layout_width="match_parent"
		        android:layout_height="wrap_content">
		
		        <ImageView
		            android:id="@+id/iv_meizi"
		            android:layout_width="match_parent"
		            android:layout_height="wrap_content"
		            android:scaleType="fitCenter" />
		
		        <TextView
		            android:id="@+id/tv_meizi"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:layout_below="@id/iv_meizi"
		            android:layout_centerHorizontal="true"
		            android:layout_marginTop="5dp" />
		    </RelativeLayout>
		
		</android.support.v7.widget.CardView>

2. 一大堆写完后，发现妹子是出来了，但是 toolbar 怎么不见了，滑动中还能透过缝看到下面的toolbar.那是因为 CoordinatorLayout 是FrameLayout,所有布局从左上角开始，并遮盖上一个，所以下面的 toolbar 就没遮盖了,但是 FloatingBar 还在上面？？？
当然你可以让 RecyclerView  向下偏移一个 toolbar 的高度 android:layout_marginTop="?attr/actionBarSize"，但我们还有更优雅的方式 appbar

### AppBarLayout

1. 加入 appBarLayout 之后

		<android.support.design.widget.AppBarLayout
		    android:layout_width="match_parent"
		    android:layout_height="wrap_content">
		
		    <android.support.v7.widget.Toolbar
		        android:id="@+id/toolbar"
		        android:layout_width="match_parent"
		        android:layout_height="?attr/actionBarSize"
		        app:layout_scrollFlags="scroll|enterAlways|snap" />
		
		</android.support.design.widget.AppBarLayout>

		并且在RecyclerView 上增加 app:layout_behavior="@string/appbar_scrolling_view_behavior"

> app:layout_scrollFlags="scroll|enterAlways|snap"  这里的类型

	1. scroll 表示跟着recyclerview 向上滚动的时候，toolbar跟着一起滚动，实现隐藏
	2. enterAlways 表示recyclerview 向下滚动时，toolbar 跟着一起向下滚动，重新显示
	3. snap 表示当toolbar 滑动到一半，显示不全时，自动选择隐藏还是显示

> behavior 要自己研究,这里 behavior 的设置要与 appbar 同级


### SwipeRefreshLayout


1. 下拉刷新,包着 recylcerview 就行了
		
		<android.support.v4.widget.SwipeRefreshLayout
		            android:id="@+id/refresh_layout"
		            android:layout_width="match_parent"
		            android:layout_height="match_parent"
		            app:layout_behavior="@string/appbar_scrolling_view_behavior">
		
		            <android.support.v7.widget.RecyclerView
		                android:id="@+id/recyler"
		                android:layout_width="match_parent"
		                android:layout_height="match_parent" />
		</android.support.v4.widget.SwipeRefreshLayout>

> 这里 behavior 要和appbarlayout 同级，所以加在了 swipeRefreshLayout 上

2. 刷新监听

		refreshLayout.setColorSchemeColors(Color.BLUE);
        refreshLayout.setOnRefreshListener(() -> new Thread(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            runOnUiThread(() -> {
                List<MeiZiBean> list = new ArrayList<>();
                for (int i = 0; i < 10; i++) {
                    MeiZiBean meiZiBean = new MeiZiBean(imageUrl, "新增--" + i);
                    list.add(meiZiBean);
                }
                adapter.addFirst(list);
                refreshLayout.setRefreshing(false);
            });
        }).start());

### 可折叠式的标题栏
1. CollcapsingToolbarLayout 

		这是一个作用在 toolbar 上的组件，它能够让toolbar 效果更加丰富。但是它只能作为 AppbarLayout的直接子布局，而AppBarLayout 又必须是CoordinatorLayout的子布局。所以这三个得一起用。



		
## 高阶技能

###　全局获取context

	public class MyApplication extends Application {
	
	    public static Context context;
	
	    @Override
	    public void onCreate() {
	        super.onCreate();
	        context = this;
	        AndroidLogAdapter adapter = new AndroidLogAdapter();
	        Logger.addLogAdapter(adapter);
	    }
	    
	    public static Context getContext() {
	        return context;
	    }
	}
