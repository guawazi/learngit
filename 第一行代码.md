# 第一行代码

## MeterDesign


### Toolbar
- 默认的主题

  <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!--actionbar 的颜色-->
        <item name="colorPrimary">@color/colorPrimary</item>
        <!--状态栏的颜色-->
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

- 修改成 NoActionBar

	1. android:theme="@style/Theme.AppCompat.Light.NoActionBar"

		淡色主题，白底黑字
	
	2. android:theme="@style/Theme.AppCompat.NoActionBar"

		深色主题，黑底白字

	3. 布局文件

			<android.support.v7.widget.Toolbar
	        android:id="@+id/toolbar"
	        android:layout_width="match_parent"
	        android:layout_height="?attr/actionBarSize"
	        />

	4. 代码中

			toolbar = (Toolbar) findViewById(R.id.toolbar);
			// 如果主题没有设置成 NoActionBar 则会报错
        	setSupportActionBar(toolbar);

	5. 配置文件中改label 就能改actionbar 的显示内容

	6. 给toolbar 配置OptionsMenu

			1. 先写

			<menu xmlns:android="http://schemas.android.com/apk/res/android"
			    xmlns:app="http://schemas.android.com/apk/res-auto">
			
			    <item
			        android:id="@+id/menu_cart"
			        android:icon="@drawable/cart"
			        android:title="cart"
			        app:showAsAction="always" />
			
			
			    <item
			        android:id="@+id/menu_delete"
			        android:icon="@drawable/delete"
			        android:title="delete"
			        app:showAsAction="ifRoom" />
			
			    <item
			        android:id="@+id/menu_category"
			        android:icon="@drawable/category"
			        android:title="分类"
			        app:showAsAction="never" />
			</menu> 

			2. 重写两个方法
			
				@Override
			    public boolean onCreateOptionsMenu(Menu menu) {
			        getMenuInflater().inflate(R.menu.toolbar, menu);
			        return true;
			    }
			
			    @Override
			    public boolean onOptionsItemSelected(MenuItem item) {
			        switch (item.getItemId()) {
			            case R.id.menu_cart:
			                Toast.makeText(this, "menu_cart", Toast.LENGTH_SHORT).show();
			                break;
			            case R.id.menu_delete:
			                Toast.makeText(this, "menu_delete", Toast.LENGTH_SHORT).show();
			                break;
			            case R.id.menu_category:
			                Toast.makeText(this, "menu_category", Toast.LENGTH_SHORT).show();
			                break;
			        }
			        return true;
			    }

### DrawerLayout

1. 左右都能侧滑
		
		<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:app="http://schemas.android.com/apk/res-auto"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    android:orientation="vertical"
		    tools:context="cn.duozhuan.aboutlambda.MainActivity">
		
		    <FrameLayout
		        android:layout_width="match_parent"
		        android:layout_height="match_parent">
		
		        <android.support.v7.widget.Toolbar
		            android:id="@+id/toolbar"
		            android:layout_width="match_parent"
		            android:layout_height="?attr/actionBarSize"
		            android:background="@color/colorPrimary" />
		    </FrameLayout>
		    
		    <TextView
		        android:text="我是左边的侧滑的菜单"
		        android:background="#FFF"
		        android:textSize="36dp"
		        android:layout_gravity="start"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent" />
		
		    <TextView
		        android:text="我是右边的侧滑的菜单"
		        android:background="#FFF"
		        android:textSize="36dp"
		        android:layout_gravity="end"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent" />
		</android.support.v4.widget.DrawerLayout>

		
		要侧滑的都带上了 layout_gravity 属性标识方向

2. 用户不知道有侧滑，加提示

		// 注意这里不是 getActionBar
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null){
            actionBar.setDisplayHomeAsUpEnabled(true);
            actionBar.setHomeAsUpIndicator(R.drawable.category);
        }

		 // 这里是 android.R. 不是 R.
            case android.R.id.home:
                drawerLayout.openDrawer(GravityCompat.START);
                break;


### NavigationView

1. 放在侧滑的位置

		   <android.support.design.widget.NavigationView
		        android:id="@+id/navigation_view"
		        android:layout_width="match_parent"
		        android:layout_height="match_parent"
		        android:layout_gravity="start"
		        app:headerLayout="@layout/navigation_head"
		        app:menu="@menu/navigation" />

> tips : 上面设置了 layout_gravity 从哪滑出来，headlayout 头布局（高度一般 180）,以及下面的菜单，都很简单

2. 设置监听事件

 		// 设置默认选中的菜单
        navigationView.setCheckedItem(R.id.item_a);
        // 监听完了，注意关闭侧滑  drawerLayout.closeDrawer(GravityCompat.START);
        navigationView.setNavigationItemSelectedListener(this);

### FloatingActionBar

1. 布局

		<android.support.design.widget.FloatingActionButton
		            android:id="@+id/fab"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            android:layout_gravity="end|bottom"
		            android:layout_margin="15dp"
		            app:elevation="20dp"
		            android:src="@drawable/a" />
> tips : 上面gravity 指定位置，elevation 指定海拔,设置监听事件跟平时一样


### SnackBar

1. 使用

		Snackbar.make(toolbar, "Data delete", Snackbar.LENGTH_LONG)
		                        .setAction("Undo",
		                                v1 -> Toast.makeText(this, "我真的被删除了", Toast.LENGTH_SHORT).show())
		                        .show();

> tips : 第一个传入的view  最好是同一个页面的view，它是用来找最外层布局的，setAction 是特有的，他会给用户提示。有一个问题，就是弹出来会遮住 FloatingBar ，这是因为，snackbar 弹出来后，floatingbar 并没有动，因为它没有接收到这个事件。

### CoordinatorLayout

1. 为了解决，floatingbar 被遮住的问题，要让它对别的控件的行为也作出反应。所以使用  coordinatorLayout,直接将FrameLayout 换成 coordinateLayout 即可。为什么这样就行呢，因为 CoordinateLayout 能监听个子控件的事件，并把它传递下去，SnackBar 好像不属于他的子控件，但是记得 SnackBar 的第一个参数么，只要它是CoordinateLayout 的子控件就行。另外，因为FloatingBar 实现了一个 Behavoir 所以，它能对 SnackBar 的弹出事件作出响应。后面会自己定义Behavoir


